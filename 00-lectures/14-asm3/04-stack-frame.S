/*
int func(int a, b)
{
        int c;
        scanf("%d", &c);
        return a + b + c;
}
*/
// в этом примере поддерживается выравнивание стека 16        
        .global func
func:
        // стандартный пролог функции
        push    %ebp
        mov     %esp, %ebp
        // сохранение callee-saved регистров
        // это не обязательно делать, так как они в этом примере не используются
        push    %ebx
        push    %esi
        // в итоге адрес возврата и сохраненные регистры (ebp, ebx, esi) займут в стеке 16 байт

        // хотя нам нужно только 4 байта для одной локальной переменной, резервируем сразу 16 чтобы поддерживать выравнивание стека
        sub     $16, %esp

        // в итоге получаем следующие смещения:
        // a: 8(ebp)
        // b: 12 (ebp)
        // c: -24(ebp)

        // резервируем 16 байт для передачи параметров в scanf
        sub     $16, %esp

        lea     -24(%ebp), %eax // получаем адрес переменной c в eax
        mov     %eax, 4(%esp)   // сохраняем в область параметров scanf
        mov     $s1, (%esp)
        call    scanf
        add     $16, %esp       // очищаем стек от параметров scanf

        // вычисляем a + b  + c в регистре eax
        mov     8(%ebp), %eax
        add     12(%ebp), %eax
        add     -24(%ebp), %eax

        // устанавливаем esp в начало области в стеке, в которой находятся сохраненные значения регистров
        // эта инструкция будет работать и в случае, когда на стеке выделялась память заранее неизвестного размера
        lea     -8(%ebp), %esp

        // восстанавливаем сохраненные регистры
        pop     %esi
        pop     %ebx
        pop     %ebp
        ret

        // строка s1 константная, предпочтительнее, чтобы она находилась в read-only секции программы
s1:     .asciz  "%d"
