        // в данном примере складываются два числа типа double
        // и результат выводится на стандартный поток вывода
        // это - 32-битная программа, не забывайте -m32 при компиляции

        .text
        .global main
main:
        movsd   a, %xmm0        // xmm0 = a; - заполняется только младшая половина (64 бита из 128) регистра xmm0
        movsd   b, %xmm1        // xmm1 = b;
        addsd   %xmm1, %xmm0    // xmm0 += xmm1 - скалярное сложение, то есть складываются только младшие 64 бита (double)
        sub     $16, %esp       // резервируем 16 байт на стеке для аргументов функции printf
        movl    $fmt, (%esp)    // форматная строка - первый аргумент
        movsd   %xmm0, 4(%esp)  // копируется 8 байт в стек - второй аргумент
        call    printf
        add     $16, %esp       // очистка стека от параметров printf
        xor     %eax, %eax      // очистка eax для кода возврата 0
        ret

        .align  8
a:      .double 1.23123
b:      .double 33.322222
fmt:    .asciz  "%.10g\n"
