/*
        В этом файле приведены примеры кода для выполнения операций над числами размера большего, чем размер регистра процесса
        Фрагменты программ написаны для архитектуры x86 и манипулируют с 64-битными целыми числами (обычно в C/C++ - тип long long)
*/

        //======= сложение =======
        // складываются два 64-битных числа
        // a : eax:edx (в eax - младшие 32 бита, в edx - старшие 32 бита)
        // b : esi:edi (в esi - младшие 32 бита, в edi - старшие 32 бита)

        addl    %esi, %eax
        adcl    %edi, %edx

        // результат a+b : eax:edx
        // кроме того, флаги будут установлены:
        // CF - unsigned overflow (carry)
        // OF - signed overflow
        // SF - sign
        // ZF - для проверки на 0 числа в eax:edx использовать нельзя! ZF зависит только от результата сложения старших частей!

        //======= проверка на 0 =======
        // a : eax:edx - проверяемое значение
        orl     %eax, %edx
        // в результате операции ZF - eax:edx == 0


        //======= сравнение двух 64-битных чисел =======
        // a : eax:edx
        // b : esi:edi
        // проверяем, что a > b

        subl    %esi, %eax
        sbbl    %edi, %edx
        ja                      // jmp if a > b

        //======= преобразование знакового 32-битного целого в знаковое 64-битное целое =======
        cdq                     // значение в eax (32-бита) знаково расширяется в значение в eax:edx (64 бита)
                                // то есть регистр edx будет содержать 0, если eax >= 0 и 0xffffffff если eax < 0
