        // в данном примере складываются два вектора double[2]
        // и результат выводится на стандартный поток вывода
        // это - 32-битная программа, не забывайте -m32 при компиляции

        .text
        .global main
main:
        movdqa  a, %xmm0        // xmm0 = a - 128 бит (два значения double) копируются из памяти по адресу a в регистр xmm0
                                // операция требует, чтобы a был выровнен по размеру вектора (16 байт)
        movdqa  b, %xmm1        // xmm1 = b
        addpd   %xmm1, %xmm0    // xmm0 += xmm1 - складываются два вектора double[2] поэлементно
        sub     $32, %esp       // резервируем место в стеке с запасом, чтобы стек был выровнен по 16
        movl    $fmt, (%esp)    // копируем первый аргумент функции printf
        movdqu  %xmm0, 4(%esp)  // копируем 128 бит, то есть double[2] в стек на место второго и третьего аргументов
                                // movdqu может выполняться медленнее чем movdqa, но зато не требует выравнивания
        call    printf
        add     $32, %esp
        xor     %eax, %eax
        ret

        .align  16              // для векторов double[2] требуется выравнивание 16
a:      .double 1.23123, -12.111111
b:      .double 33.322222, -0.2222222
fmt:    .asciz  "%.10g %.10g\n"
