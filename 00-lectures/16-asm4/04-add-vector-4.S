        // в данном примере складываются два вектора double[4]
        // и результат выводится на стандартный поток вывода
        // это - 32-битная программа, не забывайте -m32 при компиляции

        .text
        .global main
main:
        vmovapd a, %ymm0        // ymm0 = a - 256 бит (double[4]), операция требует, чтобы a был выровнен по размеру вектора (32 байта)
        vmovapd b, %ymm1        // ymm1 = b
        vaddpd  %ymm1, %ymm0, %ymm0 // ymm0 = ymm1 + ymm0 - это трехадресная операция с явно записываемым регистром результата
                                // такие операции типичны для RISC процессоров
        sub     $64, %esp       // резервируем место для аргументов printf на стеке
        movl    $fmt, (%esp)
        vmovupd %ymm0, 4(%esp)  // в отличие от vmovapd инструкция vmovupd не требует выровненного адреса в памяти, но может быть медленнее
        call    printf
        add     $64, %esp
        xor     %eax, %eax
        ret

        .align  32              // для векторов double[4] требуется выравнивание 32
a:      .double 1.23123, -12.111111, 10.10, 23
b:      .double 33.322222, -0.2222222, -10.10, 44
fmt:    .asciz  "%.10g %.10g %.10g %.10g\n"
